<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Building</li><li class="chapter-item expanded "><a href="building.html"><strong aria-hidden="true">1.</strong> Compiling Qrates</a></li><li class="chapter-item expanded affix "><li class="part-title">Extractor</li><li class="chapter-item expanded "><a href="extractor_crates_io.html"><strong aria-hidden="true">2.</strong> Extracting Data from Crates Published on crates.io</a></li><li class="chapter-item expanded "><a href="extractor_private.html"><strong aria-hidden="true">3.</strong> Extracting Data from a Private Rust Project</a></li><li class="chapter-item expanded affix "><li class="part-title">Database</li><li class="chapter-item expanded "><a href="creating_database.html"><strong aria-hidden="true">4.</strong> Creating the Database</a></li><li class="chapter-item expanded "><a href="database_structure.html"><strong aria-hidden="true">5.</strong> Database Structure</a></li><li class="chapter-item expanded affix "><li class="part-title">Queries</li><li class="chapter-item expanded "><a href="queries_run_existing.html"><strong aria-hidden="true">6.</strong> Running Existing Queries</a></li><li class="chapter-item expanded "><a href="queries_add_new.html"><strong aria-hidden="true">7.</strong> Add a New Query</a></li><li class="chapter-item expanded affix "><li class="part-title">Analysis</li><li class="chapter-item expanded "><a href="analysis_jupyter.html"><strong aria-hidden="true">8.</strong> Analysing Query Results with Jupyter</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#qrates-analysing-rust-code-corpus" id="qrates-analysing-rust-code-corpus">Qrates: Analysing Rust Code Corpus</a></h1>
<p><strong>Qrates</strong> is a tool for running large scale analyses of Rust code. To be scalable, the process is split into four phases:</p>
<ol>
<li><em>Data extraction.</em> <code>extractor</code> is a modified version of the Rust compiler that saves the information about the compiled crate to a file so that it can be easily accessed later.</li>
<li><em>Database creation.</em> To be able to run queries that span multiple crates, the information from multiple files need to be merged into a single database.</li>
<li><em>Queries.</em> The content of the database can be queried by using Rust programs. The procedural macros from <a href="https://github.com/lqd/datapond">Datapond</a> can be used to write fix-point computations in Datalog.</li>
<li><em>Query results analysis.</em> Typically, the query results are saved as CSV files so that they can be easily visualized by using data analysis tools such as <a href="https://pandas.pydata.org/">Pandas</a>.</li>
</ol>
<h1><a class="header" href="#compiling-qrates" id="compiling-qrates">Compiling Qrates</a></h1>
<p><strong>Note:</strong> These instructions were tested on Ubuntu 18.04 and 20.04.</p>
<p>Install dependencies:</p>
<pre><code class="language-bash">sudo apt install build-essential curl git libssl-dev
</code></pre>
<p>Install Rust:</p>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
source $HOME/.cargo/env
</code></pre>
<p>Clone the repository and all its dependencies:</p>
<pre><code class="language-bash">git clone https://github.com/rust-corpus/qrates.git
cd qrates
git submodule update --init
</code></pre>
<p>Add the missing components (we need them because the extractor uses the Rust compiler as a library):</p>
<pre><code class="language-bash">rustup component add rustc-dev
rustup component add rust-src
rustup component add llvm-tools-preview
</code></pre>
<p>Build the project in release mode:</p>
<pre><code class="language-bash">cargo build --all --release
</code></pre>
<h1><a class="header" href="#extracting-data-from-crates-published-on-cratesio" id="extracting-data-from-crates-published-on-cratesio">Extracting Data from Crates Published on crates.io</a></h1>
<p>This section shows how to extract data from crates published on <a href="https://crates.io/">crates.io</a>.</p>
<p><strong>Warning:</strong> The extraction involves compiling the crates and, therefore, may result in running potentially malicious code on your system. Therefore, make sure to compile the code on a virtual machine or in some other throw-away environment.</p>
<p>This section assumes that you have already compiled Qrates. You can find the instructions how to do that <a href="building.html">here</a>.</p>
<h2><a class="header" href="#obtaining-the-list-of-packages" id="obtaining-the-list-of-packages">Obtaining the List of Packages</a></h2>
<p>The second step is to select the packages<sup class="footnote-reference"><a href="#package">1</a></sup> from which we want to extract the data. This list of packages should be stored in the file <code>CrateList.json</code>. For example, if you want to analyse the package <code>rand</code>, create <code>CrateList.json</code> with the following contents:</p>
<div class="footnote-definition" id="package"><sup class="footnote-definition-label">1</sup>
<p>A package uploaded on crates.io can contain several crates. For example, it is common for executables to be split into an executable crate and a library crate.</p>
</div>
<pre><code class="language-json">{
  &quot;creation_date&quot;: {
    &quot;secs_since_epoch&quot;: 1579271281,
    &quot;nanos_since_epoch&quot;: 847419904
  },
  &quot;crates&quot;: [
    {
      &quot;Package&quot;: {
        &quot;name&quot;: &quot;rand&quot;,
        &quot;version&quot;: &quot;0.7.3&quot;
      }
    }
  ]
}
</code></pre>
<p>If you want to analyse all packages on crates.io, you can rename <code>CrateList-all-2020-01-14.json</code> to <code>CrateList.json</code>. That file contains the latest versions of all packages that were published on crates.io on 2020-01-14. Please note that compiling all packages requires at least 1 TB of hard drive space and running queries on so large dataset may require up to 200 GB of RAM. The dataset <code>CrateList-top-200-2020-01-17.json</code> 200 packages that were the most downloaded on crates.io; this dataset should be analysable on a laptop with 8 GB of RAM.</p>
<p>You can also create the list with the latest versions of all packages by running the following command:</p>
<pre><code class="language-bash">cargo run --release -- init-all
</code></pre>
<h2><a class="header" href="#compiling-the-packages" id="compiling-the-packages">Compiling the Packages</a></h2>
<p><em>Note:</em> Instead of compiling yourself, you can also download the extracted data from <a href="https://doi.org/10.5281/zenodo.4026639">here</a>.</p>
<p>Qrates uses the <a href="https://github.com/rust-lang/rustwide/">Rustwide</a> library for compiling packages. Please see the Rustwide documentation for the system requirements; most importantly you need to have <a href="https://www.docker.com/">Docker</a> installed (you can find the installation instructions <a href="https://docs.docker.com/engine/install/">here</a>).</p>
<p>You can start the compilation as follows:</p>
<pre><code class="language-bash">mkdir ../workspace
cargo run --release -- compile
</code></pre>
<p>This command may fail with a permission error if the user does not have the necessary permissions to communicate with the Docker manager. In that case, use <code>sudo</code>:</p>
<pre><code class="language-bash">sudo $(which cargo) run --release -- compile
</code></pre>
<p>Attempting to compile all packages from crates.io on Lenovo ThinkPad T470p takes about a week. You can check how many packages already successfully compiled by running the following command:</p>
<pre><code class="language-bash">ls ../workspace/rust-corpus/*/success | wc -l
</code></pre>
<p><em>Note:</em> it is likely that the number of successfully compiled packages will be smaller than the one we reported in the paper because some of the packages were removed from crates.io in the meantime.</p>
<h2><a class="header" href="#checking-compilation-results" id="checking-compilation-results">Checking Compilation Results</a></h2>
<p>The overview of compilation errors can be seen by running the following command:</p>
<pre><code class="language-bash">cargo run --release -- check-compilation
</code></pre>
<p>It will print the statistics of how many crates failed to compile for some common reason, how many failed likely due to a bug in the extractor, and how many failed for yet unrecognised reason. It will also print 5 paths of each of the latter groups.</p>
<p><em>Note:</em> The classification is implemented in <code>manager/src/compilation_checks.rs</code>.</p>
<p>If you are using an older <code>CrateList</code>, it is very likely that many crates will fail to compile because their dependencies were removed from the registry (they were “yanked”). One workaround for this problem would be to fork <a href="https://github.com/rust-lang/crates.io-index">the crates.io registry</a> and then restore the removed crates by setting their <code>yanked</code> flag to <code>False</code>. It is also recommended to remove all package versions that are newer than the ones in the the crate list. Both these operations could be done by executing the following script from the root directory of the registry repository:</p>
<pre><code class="language-python">#!/usr/bin/python3

import json
import os

CRATE_LIST = '&lt;path-to&gt;/CrateList-all-2020-01-14.json'

def rewrite(path, package, versions):
    &quot;&quot;&quot;Rewrite the cargo registry entry for `package` to contain only
    the entries older than the one mentioned in `versions` and restore
    all yanked version.
    &quot;&quot;&quot;
    if package not in versions:
        # This package probably was published after we created the
        # crates list and, therefore, will not appear among
        # dependencies.
        return
    newest_version = versions[package]
    with open(os.path.join(path, package)) as fp:
        try:
            lines = fp.read().splitlines()
        except:
            print(path, package)
            raise
    with open(os.path.join(path, package), 'w') as fp:
        for line in lines:
            data = json.loads(line)
            if 'yanked' in data and data['yanked']:
                data['yanked'] = False
                json.dump(data, fp, separators=(',', ':'))
            else:
                fp.write(line)
            fp.write('\n')
            if data['vers'] == newest_version:
                break

def main():
    with open(CRATE_LIST) as fp:
        crates = json.load(fp)['crates']
        versions = dict(
            (crate['Package']['name'], crate['Package']['version'])
            for crate in crates
        )

    for root, dirs, files in os.walk('.'):
        if root != '.':
            for package in files:
                rewrite(root, package, versions)
        else:
            dirs.remove('.git')

if __name__ == '__main__':
    main()
</code></pre>
<p>The registry that matches <code>CrateList-all-2020-01-14.json</code> can be found <a href="https://github.com/vakaras/crates.io-index">here</a>. To try recompiling all failed packages with this registry, execute the following commands:</p>
<pre><code class="language-bash">cargo run --release -- check-compilation --delete-failures
cargo run --release -- compile --purge-build-dir --custom-cargo-registry https://github.com/vakaras/crates.io-index
</code></pre>
<h2><a class="header" href="#moving-extracted-data" id="moving-extracted-data">Moving Extracted Data</a></h2>
<p>Since the extraction phase has quite different technical requirements from the later phases, it is common to execute these phases on different machines. The following command can be used to move deduplicated extracted data to a new directory for easy transfer:</p>
<pre><code class="language-bash">cargo run --release -- move-extracted &lt;target-dir&gt;
</code></pre>
<p>The command sleeps for 20 seconds after it collects the list of files to move and performing the actual move to reduce the risk of moving half-written files.</p>
<p>It will also generate <code>files.json</code> files that are then used by one of the queries to select the builds for analysis. Please note that some packages (for example, <code>sheesy-cli-4.0.7</code> and <code>actix-net-0.3.0</code>) are empty when compiled with default features, which results in <code>files.json</code> being empty.</p>
<h1><a class="header" href="#extracting-data-from-a-private-rust-project" id="extracting-data-from-a-private-rust-project">Extracting Data from a Private Rust Project</a></h1>
<p>This section shows how to extract data from a private Rust project.</p>
<h2><a class="header" href="#building-qrates" id="building-qrates">Building Qrates</a></h2>
<p>The first step is to check out and compile Qrates:</p>
<pre><code class="language-bash">git clone https://github.com/rust-corpus/qrates.git
cd qrates
git submodule update --init
cargo build --all --release
</code></pre>
<p>After the successful build, in the <code>target/release</code> directory there should be an executable file called <code>rustc</code>. We will extract the information by using this special <code>rustc</code> to compile the project. To do so, we need to set environment variable <code>RUSTC</code> to contain its path:</p>
<pre><code class="language-bash">export RUSTC=&quot;$(pwd)/target/release/rustc&quot;
</code></pre>
<p>We also need to set the environment variable <code>SYSROOT</code> to contain the sysroot of the Rust version we used to compile Qrates and <code>LD_LIBRARY_PATH</code> to contain the <code>lib</code> directory in <code>SYSROOT</code>:</p>
<pre><code class="language-bash">export SYSROOT=&quot;$(rustc --print sysroot)&quot;
export LD_LIBRARY_PATH=&quot;$SYSROOT/lib&quot;
</code></pre>
<p>We also need to create a directory to store the extracted data and set the environment variable <code>CORPUS_RESULTS_DIR</code> to point to it:</p>
<pre><code class="language-bash">mkdir -p ../workspace/rust-corpus/
export CORPUS_RESULTS_DIR=&quot;$(pwd)/../workspace/rust-corpus/&quot;
</code></pre>
<h2><a class="header" href="#compiling-a-project" id="compiling-a-project">Compiling a Project</a></h2>
<p>As an example, let's try to extract information from the <code>master</code> branch of the <a href="https://github.com/rust-random/rand">rand</a> crate.</p>
<p>Clone the <code>rand</code> crate repository:</p>
<pre><code class="language-bash">cd /tmp
git clone https://github.com/rust-random/rand.git
cd rand
</code></pre>
<p>Check that the environment variables <code>RUSTC</code>, <code>SYSROOT</code>, <code>LD_LIBRARY_PATH</code>, and <code>CORPUS_RESULTS_DIR</code> are set correctly.</p>
<p>Compile the project:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>If the compilation was successful, <code>CORPUS_RESULTS_DIR</code> directory should contain many <code>bincode</code> files:</p>
<pre><code class="language-console">$ ls $CORPUS_RESULTS_DIR
build_script_build_641a6913d88f2b1b.bincode  ppv_lite86_89695c0a0a962fc8.bincode
build_script_build_679051cf1df6d8f8.bincode  rand_0330e33c1ee64866.bincode
cfg_if_f903336a35b88a26.bincode              rand_chacha_23c71b977e463cb8.bincode
getrandom_9a46159fdf341523.bincode           rand_core_272caddfb637ce01.bincode
</code></pre>
<h1><a class="header" href="#creating-the-database" id="creating-the-database">Creating the Database</a></h1>
<p>To be able to run queries, the extracted information must be merged into a single database. Assuming you followed one of the previous sections for extracting files, you can create the database by running the following command from the directory in which you cloned Qrates:</p>
<pre><code class="language-bash">cargo run --release -- update-database
</code></pre>
<p>This command expects to find the extracted files in directory <code>../workspace/rust-corpus/</code>. If you stored them somewhere else, you can specify the path to the workspace by using the <code>--workspace</code> argument.</p>
<h1><a class="header" href="#database-structure" id="database-structure">Database Structure</a></h1>
<p>As was mentioned in the introduction, the process is split into four phases:</p>
<ol>
<li>Extracting the information about each crate.</li>
<li>Merging the information into a single database.</li>
<li>Running queries over the database.</li>
<li>Analysing the query results.</li>
</ol>
<p>This design was motivated by the fact that the extraction phase is time consuming (can take up to a week for the entire crates.io) and depends on internal compiler APIs that are unstable and change often: we decided to make the extractor as minimal as possible and handle the main workload in the later phases. This is also reflected in the Datalog database schema by splitting into two parts:</p>
<ol>
<li><code>database/src/schema.dl</code> – core data, which is generated by the extractor. Modifications made to this file require rerunning the extractor.</li>
<li><code>database/src/derived.dl</code> – derived data, or, in other words, data computed by the queries and stored in the database so that it can be reused by other queries.</li>
</ol>
<p>The following subsections present how the data is stored in the database and present some of the most important derived queries.</p>
<h2><a class="header" href="#database-format" id="database-format">Database Format</a></h2>
<p>The database is inspired by Nicholas D. Matsakis <a href="http://smallcultfollowing.com/babysteps/blog/2017/02/17/project-idea-datalog-output-from-rustc/">blog post</a> in which he suggested to make the Rust compiler to output Datalog which then could be used to write interesting queries. <code>schema.dl</code> defines three kinds of elements:</p>
<ol>
<li>Types – we decided to use a strongly typed variant of Datalog; therefore, most elements have unique types.</li>
<li>Interning tables – we use them for two main reasons:
<ol>
<li>To reduce the memory requirements by replacing complex objects such as strings with unique integers and using them instead.</li>
<li>To map a specific type such as <code>Package</code> to a generic type such as <code>InternedString</code>.</li>
</ol>
</li>
<li>Datalog relations – that similarly to SQL tables capture the relational information between program elements.</li>
</ol>
<p><code>derived.dl</code> can define additional relations.</p>
<p>From <code>schema.dl</code> and <code>derived.dl</code>, a procedural macro generates the code that manages the database. Most importantly, it generates the <a href="https://rust-corpus.github.io/qrates/doc/corpus_database/tables/struct.Tables.html"><code>Tables</code></a> object that is used by the extractor to store the extracted data and the <a href="https://rust-corpus.github.io/qrates/doc/corpus_database/tables/struct.Loader.html"><code>Loader</code></a> object that is used by the queries to load the data.</p>
<h2><a class="header" href="#fundamental-derived-queries" id="fundamental-derived-queries">Fundamental Derived Queries</a></h2>
<p>While, in theory, the core schema should be self-contained, the fact that changes to it require rerunning the extractor made us to put some of the fundamental relations to <code>derived.dl</code>. The most important of such relations is <code>selected_builds</code> and many other <code>selected_*</code> relations that are derived from it. To understand the purpose of the <code>selected_builds</code> relation, we need first to explain the differences between <em>packages</em>, <em>crates</em>, and <em>builds</em>:</p>
<ul>
<li>Packages are archives stored on crates.io. Packages have versions and their names are unique within a registry. A single package can define one or more crate. Packages can also define feature flags that allow customizing compilation by, for example, including some functions only if the specific feature is enabled.</li>
<li>A crate is a unit of compilation. A crate needs to have a unique name within a package, but its name is not guaranteed to be unique within a package registry (for example, we found 50 crates named <code>main</code> in our dataset).</li>
<li>A build is a crate from a specific version of a package compiled with the specific configuration flags.</li>
</ul>
<p>When compiling all packages from crates.io, we often have multiple builds coming from the same crate. For example, this could happen when two packages <code>A</code> and <code>B</code> depends on different versions (or with different features) of the third package <code>C</code>. If we used all these builds in our analysis, we would get skewed results because the packages that have many versions and more feature flags would be included more times. Therefore, we defined a relation <code>selected_builds</code> that contains only a single build for each crate. The build is chosen by picking a build from the package version that is specified in <code>CrateList.json</code>. If there are more than one such build (for example, because of different feature flags), we choose the first one in the iteration order (basically at random). We also remove from <code>selected_builds</code> all builds from crates whose names start with <code>build_script_</code> because they are results of compiling the <code>build.rs</code> files.</p>
<h1><a class="header" href="#running-existing-queries" id="running-existing-queries">Running Existing Queries</a></h1>
<p>To run all existing queries, execute:</p>
<pre><code class="language-bash">cargo run --release -- query all
</code></pre>
<p>This will invoke the query <code>all</code> that is a meta-query that runs all other queries. The queries are defined in <code>manager/src/queries</code>. You can find the documentation of what exactly each of them does in their doc-comments.</p>
<p>Most queries store results in CSV files that can be found in the <code>../workspace/reports</code> directory.</p>
<h1><a class="header" href="#add-a-new-query" id="add-a-new-query">Add a New Query</a></h1>
<p>This chapter shows how to define your own query. Adding a new query typically involves the following steps:</p>
<ol>
<li>Checking the database and determining what information needs to be loaded.</li>
<li>Implementing the function that takes the information and computes the desired result.</li>
<li>Writing the result into a CSV file.</li>
<li>Registering the query in the queries list.</li>
</ol>
<p>Each of the following sections discuss each step in more detail. As an example, we use a query that finds the definitions of types that have raw pointers as fields and are not annotated as <code>#[repr(C)]</code> (<code>manager/src/queries/non_tree_types.rs</code>).</p>
<h2><a class="header" href="#database-structure-1" id="database-structure-1">Database Structure</a></h2>
<p>Before we can define a new query, we need to understand the database structure. The database schema is defined in two files:</p>
<ol>
<li><code>database/src/schema.dl</code> – core data, which is generated by the extractor. Modifications made to this file require rerunning the extractor.</li>
<li><code>database/src/derived.dl</code> – derived data, or, in other words, data computed by the queries and stored in the database so that it can be reused by other queries.</li>
</ol>
<p>From these schemas, the procedural macros generate various data structures and functions. For writing queries, the most important data structure is <a href="https://rust-corpus.github.io/qrates/doc/corpus_database/tables/struct.Loader.html">Loader</a> that allows loading the relations stored in the database as Rust vectors. <code>&amp;Loader</code> is passed as an argument to each query.</p>
<p>One very important derived relation is <code>selected_builds</code> that is created from the <code>CrateList.json</code> the by query <code>prepare-builds</code>. Since we can have more than one build of the same crate (for example, if we had among dependencies different versions of a crate or the same crate with different configuration flags), to avoid duplicates in the analysis the <code>selected_builds</code> relation stores which builds should be analysed by queries.</p>
<p>For our query, we are interested in three relations:</p>
<ol>
<li><code>types_adt_field</code> – the relation between fields and their types.</li>
<li><code>types_raw_ptr</code> – the relation that contains all types that are raw pointers.</li>
<li><code>selected_adts</code> – the derived relation that contains the abstract data types such as <code>enum</code> or <code>struct</code> defined in <code>selected_builds</code>.</li>
</ol>
<h2><a class="header" href="#computing-the-relation" id="computing-the-relation">Computing the Relation</a></h2>
<p>For your query, create a new module in <code>manager/src/queries/mod.rs</code>. For example:</p>
<pre><code class="language-rust no_run noplayground">mod non_tree_types;
</code></pre>
<p>The module should contain the function <code>query</code>:</p>
<pre><code class="language-rust no_run noplayground">pub fn query(loader: &amp;Loader, report_path: &amp;Path) {
    // Query implementation.
}
</code></pre>
<p>Here, <code>loader</code> is the <code>Loader</code> object mentioned in the previous section and <code>report_path</code> is the folder in which we should store the CSV files.</p>
<p>Before we write the result to a CSV file, we will obtain a vector of types that contain raw pointer fields. We can do this via a simple Datalog query (we are using <a href="https://github.com/lqd/datapond">Datapond</a> library):</p>
<pre><code class="language-rust no_run noplayground">// Declare the output variable.
let non_tree_types;
datapond_query! {
    // Load the relations by using “loader”.
    load loader {
        relations(types_adt_field, types_raw_ptr),
    }
    // Specify that “non_tree_types” is the output variable.
    output non_tree_types(typ: Type)
    // Define the relation by using a Datalog rule:
    non_tree_types(adt) :-
        types_adt_field(.adt=adt, .typ=typ),
        types_raw_ptr(.typ=typ).
}
</code></pre>
<p>To generate the readable CSV file with the information, we need to traverse the list of all relevant adts, check for each of them whether it is one of the types from <code>non_tree_types</code> and if yes, desugar to a human readable format. To make the checking more efficient, we can convert <code>non_tree_types</code> from a vector to a hash set. The code would be:</p>
<pre><code class="language-rust no_run noplayground">let non_tree_types: HashSet&lt;_&gt; = non_tree_types.elements.iter().map(|&amp;(typ,)| typ).collect();
let non_tree_adts = selected_adts.iter().flat_map(
    |&amp;(
        build,
        item,
        typ,
        def_path,
        resolved_def_path,
        name,
        visibility,
        type_kind,
        def_kind,
        kind,
        c_repr,
        is_phantom,
    )| {
        if non_tree_types.contains(&amp;typ) {
            Some((
                build,
                build_resolver.resolve(build),
                item,
                typ,
                def_path_resolver.resolve(def_path),
                def_path_resolver.resolve(resolved_def_path),
                &amp;strings[name],
                visibility.to_string(),
                &amp;strings[type_kinds[type_kind]],
                def_kind.to_string(),
                kind.to_string(),
                c_repr,
                is_phantom,
            ))
        } else {
            None
        }
    },
);
</code></pre>
<p>Finally, we can write the results to the CSV file:</p>
<pre><code class="language-rust no_run noplayground">write_csv!(report_path, non_tree_adts);
</code></pre>
<p>The results will be written to a file <code>../workspace/reports/&lt;query-name&gt;/&lt;iterator-variable&gt;.csv</code>.</p>
<h1><a class="header" href="#analysing-query-results-with-jupyter" id="analysing-query-results-with-jupyter">Analysing Query Results with Jupyter</a></h1>
<p><a href="https://jupyter.org/">Jupyter notebook</a> is a web application commonly used by data scientists to analyse and visualise their data. If you have Docker installed (you can find the installation instructions <a href="https://docs.docker.com/engine/install/">here</a>), you can start a local Jupyter instance as follows:</p>
<pre><code class="language-bash">make run-jupyter
</code></pre>
<p><em>Note:</em> Since using Docker requires root permissions, this command will ask for the <code>sudo</code> password.</p>
<p>The command will print to the terminal a message like this:</p>
<pre><code class="language-plain">[C 10:33:17.685 NotebookApp]

    To access the notebook, open this file in a browser:
        file:///home/jovyan/.local/share/jupyter/runtime/nbserver-27-open.html
    Or copy and paste one of these URLs:
        https://4ad49d6251da:8888/?token=202176e7bd7283e90ba6321c58472d193f41e27ba0da2b41
     or https://127.0.0.1:8888/?token=202176e7bd7283e90ba6321c58472d193f41e27ba0da2b41

</code></pre>
<p>Click on one of the links to open the notebook in your default browser. The notebook uses a self-signed certificate and, as a result, your browser will show an SSL error. Just ignore it.</p>
<p>If everything started successfully, you should see three folders listed: <code>data</code>, <code>reports</code>, and <code>work</code>. Click on <code>reports</code>. It should contain six files with <code>.ipynb</code> extensions–these are Python notebooks used to analyse the data presented in the paper.</p>
<p>After you open a notebook (for example, by clicking on <code>Builds.ipynb</code>), you can re-execute it by choosing <em>Kernel</em> → <em>Restart &amp; Run All</em>. (Note that some <code>assert</code> statements in the notebooks assume the full dataset; feel free to comment them out.)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
